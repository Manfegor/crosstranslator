\Chapter{Szintaktikai elemzés}

% TODO: Formális nyelvekkel, fordítóprogramokkal kapcsolatos könyvek hivatkozásai.

% http://www.informatik.uni-bremen.de/agbkb/lehre/ccfl/Material/ALSUdragonbook.pdf

\section{Java parser generátorok}

Az Interneten sokféle parser generátor található, mely segítségével a szintaktikai elemzés könnyebbé válik, megoldható.
A feladat megoldásához olyan parser generátorra van szükség, mely Java nyelvű, mivel a fordítóprogram ezen a nyelvek kerül megírása.
Emellett a parser generátorok feldolgozás szempontjából is sokfélék, és jelen feladathoz olyan generátort kellett keresni, mely reguláris nyelvvel képes működni.
Az alábbiakban a legelterjedtebb ilyen generátorokat vizsgáljuk meg.

\subsection{AnnoFlex}

Az Annoflex egy Java alapú parser generátor, mely szabadon letölthető és használható, sőt módosítható is. Az AnnoFlex implementálható mind az Eclipse, mind a InteliJ fejlesztőpi környezetekbe, külső eszközként, így bármikor használható lesz.

AZ AnnoFlex megalkotáskor is a használata minél egyszerűbbé tétele volt a fő szempont, legegyszerűbb esetben az alábbi kódot kell megírnunk:

\begin{java}
/**
* @option methodName = getNextToken
* @option statistics = enabled
*/
public class Example_Annoflex {
/** @expr [0-9]+       */ String createNumber()     { return "number"; }
/** @expr [a-zA-Z]+    */ String createIdentifier() { return "identifier"; }
/** @expr [ \n\r\t\f]+ */ String createWhitespace() { return "whitespace"; }

//%%LEX-MAIN-START%%


//%%LEX-MAIN-END%%
}
\end{java}

Az AnnoFlexnek meg kell adni a beállításokat, méghozzá a megvalósítása szerint az osztálynév előtt és komment formájában kell megadni őket, valamint fontos, hogy a @option annotáció előzze meg őket. Példánkban a metódus nevét állítottuk be, illetve azt, hogy a generálás során statisztikát jelenítsen meg a program.

Ezután az osztályon belül meg kell adni a kifejezéseket és a metódusokat. Itt találkozhatunk több megkötéssel is az AnnoFlex tekintetében. A megadáskor mindenképpen @expr kifejezéssel kell kezdeni, melyet szintén kommentben kell elhelyezni.

A kifejezés után csak és kizárólag reguláris kifejezés állhat. A komment után magát a metódust kell megírni, melynél szintén van megkötés. A metódusok nem lehetnek static módosítóval ellátva, visszatérési értékük nem lehet csak primitív típus vagy String, de mindenképpen az összes így megadott metódusnak ugyanolyan visszatérési értékkel kell bírnia, egyetlen kivétellel, ami a void. Void visszatérési érték állhat más visszetérési érték mellett. További megkötés, hogy a metódusoknak nem lehet paraméterük, csak visszatérési értékük.

Minden egyes metódust csak egy darab reguláris kifejezés előzhet meg, ha több reguláris kifejezés is kellene, hogy ott álljon, akkor a reguláris kifejezések uniójával oldható ez meg, melyhez a | operátor használható.

Ez után következik egy tagek által határolt üres rész, ezt mindig a //%%LEX-MAIN-START%% és //%%LEX-MAIN-END%% határolja, és ide kerül legenerálásra a tulajdonképpeni kód. Ebben ad nagy segítséget az AnnoFlex.

Amennyiben elkészültünk a kifejezések megírásával, akkor a fejlesztőkörnyezetben lefuttathatjuk a AnnoFlex programot, mely eredménye a következő lesz:

% TODO: Itt csak behivatkozni majd valahogy a generált kódot, és csak néhány érdekesebb kódrészt mutatni belőle!

% TODO: Fel lehet sorolni a generált adattagokat és metódusokat!

A fenti kódban látható, hogy a program legenerálta a szükséges metódusokat és funkciókat. Ezután már nem kell mást tenni, mint egy futtatható osztályt készíteni a példához:

\begin{java}
public class Example_AnnoRun {

	public static void main(String[] args) {
		Example_Annoflex anno = new Example_Annoflex();
		anno.setString("Ez 1 teszt string");
		System.out.println("Scan:" + anno.getString());
		String token = anno.getNextToken();
		while (token != null) {
			System.out.println(token + ":" + anno.getMatchText());
			token = anno.getNextToken();
		}
	}

}
\end{java}

Ebben csak létrehozunk egy példányt az osztályból, hozzáadunk egy szöveget és lefuttatjuk a programot. A képernyőre a következő eredményt fogja a program kiírni:

\begin{verbatim}
Scan:Ez 1 teszt string
identifier:Ez
whitespace: 
number:1
whitespace: 
identifier:teszt
whitespace: 
identifier:string
\end{verbatim}

Látható, hogy identifier-nek jelezte a szövegeket, a számot numberként jelenítette meg és megtalálta a fehér karaktereket is, azaz a szóközöket.

\subsection{JFlex}

A JFlex szigorú értelembe véve egy lexikai elemző, azaz lexer generátor, mely Java nyelvhez Java nyelven írt generátor. Itt is a megadott inputot próbálja meg illeszteni a különféle előre definiált nyelvtani elemekre és az annak megfelelő utasításokat hajtja végre.

A JFlex a JLex átírt változata, melynek átírásakor a cél a teljes unicode támogatás és platformfüggetlenség volt, illetve a gyors szkenner generálás, kényelmes szintaktika és az is, hogy kompatibilis legyen a JLex-el. Önállóan is használható, de mivel főképp lexer generátor, így más parser generátorokkal történő együttműködésre tervezték, leginkább a CUP parserrel kompatibilis.

Felépítése alapján a nyelvtani specifikáció három részre osztható, melyeket a \texttt{\%\%} jel választ el. Az első a felhasználói kód, a második a beállítások és makrók része, míg a harmadik fogja tartalmazni a lexer szabályokat.

% TODO: Itt is csak említeni kellene a példával kapcsolatban néhány észrevételt!

\subsection{AustenX}

Az AustenX, vagy röviden csak Austen szinten egy parser generátor. Az Austen jelenleg csak Java nyelven nyújt generátort, és az előzőekhez hasonlóan ez is reguláris nyelv alapján dolgozza fel a kódot.

Az Austin egy jar fájlként tölthető le és futtatható, aminek futtatásakor paraméterként kell megadni a célfájlt. Az Austen futtatható a jar fájlra kattintva duplán, ilyenkor egy egyszerű felhasználói kezelőfelület nyílik meg. Itt meg kell adni a forrásfájlok helyét, amiben a feldolgozáshoz szükséges adatok vannak, illetve a célfájl helyét, ahova a feldolgozott fájlok kerülnek. A forrásfájlok .austen vagy .austenx kiterjesztéssel kell, hogy rendelkezzenek. Az alábbiakban egy egyszerűbb példa látható a forrásfájlokra.

% TODO: Tömören össze kellene foglalni a generált kódot.

A fenti kód egy általános leírást tartalmaz, library-k szerint szervezve melyet felhasznál az alábbi kód, ami a parser generator pontos leírását tartalmazza.
