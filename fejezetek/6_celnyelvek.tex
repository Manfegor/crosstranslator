\Chapter{Célnyelvre fordítás}

Az alábbi részben a tervezett célnyelvek szintaxisának, elemeinek áttekintése történik meg a hangsúlyt az egyes célnyelvek különbözőségeire fektetve.

\section{Nyelvi típusok}

Az alábbiakban egy összefoglaló látható a különböző nyelvi típusokról, hogy az egyes célnyelvekben megjelenik-e az adott típus és ha igen akkor milyen formában. Ez alapján egy áttekintést kaphatunk arról, hogy a megírt kód lefordítása után az egyes nyelveket a típusok hogyan jelennek meg.
A kapott táblázat alapján meg tudjuk majd állapítani, hogy mely típusok jelennek meg a nyelvek nagy többségében, azaz a fordítás során mely típusokat kell mindenképpen figyelembe venni, megvalósítani.

Mivel a programozási nyelv megalkotása és a fordító megvalósítása során mindvégig a könnyű használhatóság és egyszerű megtanulhatóság lett szem előtt tartva, ezért jelen verzióban csak a fent említett közös típusok kerülnek megvalósításra. A későbbiekben ez bővíthető, hogy az egyes célnyelvek minden elemét tudja a program kezelni.

\begin{table}
	\caption{Programozási nyelvi típusok}
	\label{2. táblázat}
	\begin{tabular}{c|c|c|c|c}
		\textbf{C} & \textbf{Python} & \textbf{Java} & \textbf{JavaScript} & \textbf{PHP}\\
		char & - & - & string & string \\
		unsigned char & - & char & - & - \\
		signed char & - & - & - & A -> - \\
		int & int & int & number & integer \\
		unsigned int & - & - & - & - \\
		short & - & short & - & - \\
		unsigned short & - & - & - & - \\
		long & - & long & - & - \\
		unsigned long & - & - & - & - \\
		float & - & float & number & float vagy double \\
		double & inf & double & number & float vagy double \\
		long double & - & - & number & - \\
		void & - & void & - & - \\
		array & array & array & array & array \\
		pointer & - & - & - & - \\
		structure & class & class & object & object/class \\
		- & str & string & string & string \\
		- & boolean & boolean & boolean & boolean \\
	\end{tabular}
\end{table}

https://www.tutorialspoint.com/cprogramming/c\_data\_types.htm

https://realpython.com/python-data-types/

https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html

https://javascript.info/types

A táblázatból látható, hogy a C nyelvben alapvetően sok különféle típus került definiálásra, melyek a további nyelvekben vagy nem jelennek meg, vagy ha meg is jelennek, közös típus alá vannak rendelve, azaz egy-egy típust kell csak megjeleníteni a kódban.

Külön érdemes kiemelni a PHP, JavaScript és a Python nyelveket, melyeknél az egyszerű típusokat nem is kell megjeleníteni a kódban, az adott változó típusát mindig az aktuális értéke határozza meg. Bár igaz, hogy a típus az érték alapján kerül meghatározásra, ettől függetlenül az idézett dokumentációkban megjelennek az egyes típusok, hiszen a nyelvek a típusokat felismerik, függetlenül attól, hogy egy változó deklarálásakor meg kell-e adni azt vagy sem.

A fenti táblázat alapján a fordítóprogram a szám és szöveg típusú változókat támogatja, emellett a tömb, boolean és struktúra típust is. Jelenleg a további típusokat a fordítóprogram nem fogja támogatni, ezek beépítése egy további fejlesztési lehetőség lehet.

A szám típusok közül jelenleg az integer típus támogatott, mivel ez a leggyakrabban használt az általunk vizsgált témakörben, a szöveg string típusú lesz, mivel ez a megszokott a programozási nyelvek tekintetében, csakúgy mint a boolean típus. A definiált programozási nyelv típusosság tekintetében a Python nyelvre hasonlít, így a típus megjelölése itt sem szükséges.
A tömb típust itt dictionary néven fogjuk kezelni, a struktúra pedig a modern, objektum-orientált nyelvekhez hasonlóan osztályokból fog állni, melyek a változókat illetve függvényeket foglalhatnak magukba.

\section{Változók deklarálása}

Az alábbi részben áttekintjük, hogy az egyes célnyelvként tekintett magas szintű programozási nyelvekben a változó deklarálásában milyen különbségeket tapasztalhatunk. Az egyes célnyelvek függően attól, hogy a típusmegjelölést ki kell-e írni, illetve, hogy milyen kulcsszóval vagy kulcsszó nélkül adjuk meg az egyes változókat nagyban különböznek. Ezt a különbséget a fordítóprogramnak kezelnie kell, és el kell fednie a felhasználó elől.

A legfontosabb különbség a C és Java nyelv illetve a Python, JavaScript és PHP hármasa között van, ahogy a különbségek nagyobb részében így lesz. A változók deklarálása során az előbbi két nyelvben minden esetben ki kell írni a változó típusát a változó neve elé, például
\begin{cpp}
	int valtozo;
\end{cpp}

Azt is megtehetjük, hogy a deklarálással együtt inicializáljuk a változót, azaz egy értéket is adunk neki. Ez minden célnyelvként vett nyelv esetében működik, azaz megtehetjük, hogy az alábbi módon adjuk meg a változót például Java nyelven:

\begin{cpp}
	int valtozo = 12;
\end{cpp}

Ezzel szemben a Python, JavaScript és PHP nyelveken a típusmegjelölést nem kell kiírni a változó elé, viszont ezen nyelvek többségében is jelezni kell, hogy egy változót adunk meg.

A Python nyelvben kivételesen nem kötelező ezt megadni, sőt a korai Python verziók esetében több helyen is megjegyzik, hogy "nem szükséges a változókat deklarálni mielőtt használjuk őket, sőt a változók típusát sem kell megadni". (https://www.learnpython.org/en/Variables\_and\_Types)
Általánosságban ilyenkor annyit mondhatunk, hogy egy nevet rendelünk egy értékhez, hogy milyen típus lesz az, azt az érték fogja meghatározni.

\begin{cpp}
	valtozo = 12
	print(valtozo)
\end{cpp}

Ennek hátránya a nehézkes kódolvasás és javítás, főleg komplex programok esetén, mivel egy adott változó bármilyen típusú értéket felvehet, de lehetséges, hogy az adott változót használó kódrésznek egy adott típusú változóra lenne szüksége, ilyen esetben nehéz lehet megtalálni a probléma pontos forrását. Ennek kiküszöbölésére a 3.6-os Python verziótól kezdődően lehetőség van a egy úgynevezett "hint" megadására a változónevek után, melyben megadhatjuk, hogy terveink szerint az adott változó milyen típusú értéket fog felvenni.

\begin{cpp}
	valtozo: str = "szöveg"
	print(valtozo)
\end{cpp}

A Pythonhoz készített ellenőrzők, például a mypy program, már képesek ezeket feldolgozni, és a Java fejlesztőkörnyezethez hasonlóan kódoláskor már jelezni az esetleges típusbeli eltéréseket. Forrás: https://medium.com/@ageitgey/learn-how-to-use-static-type-checking-in-python-3-6-in-10-minutes-12c86d72677b

A JavaSript nyelvben ismét más megoldást vezettek be a változók esetében, itt a Java nyelvhez hasonlóan deklarálni kell a változókat, azonban típust itt sem kell megadnunk. A deklarálás mikéntjének vizsgálatában ismét először nézzük meg a régebbi verziókat először. Itt még csak a var kulcsszóval történik a deklaráció, és szokásos módon itt is azonnal értéket is tudunk adni a változónak.

\begin{cpp}
	var valtozo;
	valtozo = "szöveg";
	
	var valtozo2 = 12;
\end{cpp}

Az ilyen módon deklarált változók minden esetben az őket bezáró funkciókban érhetők csak el, illetve globálisan ha nincs bezáró funkció.
Az ECMAScript 2015 bevezetésekor változott ez meg, ami ECMAScript6 néven terjedt el a programozók körében. Ebben bevezettek két új váltózó típust és deklarálásukat.

\begin{cpp}
	let valtozo = "szöveg";
	
	const valtozo = "szöveg";
\end{cpp}

A let esetében, nem csak a bezáró funkcióban, de azon belül is csak abban a bezáró blokkban használható, ahol deklarálva lett.

\begin{cpp}
	var valtozo = 5;
	console.log(valtozo);
	{
		let valtozo = 8;
		console.log(valtozo);
	}
	console.log(valtozo);

\end{cpp}

A fenti példában az első konzol kiíratás 5-öt fog megjeleníteni, a második 8-at, míg a harmadik szintén 5-öt. Azonban fontos megjegyezni, hogy ha így írjuk meg a kódot

\begin{cpp}
	{
		let valtozo = 8;
		console.log(valtozo);
	}
	console.log(valtozo);
	
\end{cpp}

akkor a második kiíratás hibára fog futni, hiszen ahogy említettük, a let kulcsszóval deklarált változó csak az adott bezáró blokkon belül érhető el.

A const kulcsszóval deklarált változók majdnem teljesen úgy működnek, mint a let kulcsszóval deklaráltak, azaz csak az adott blokkon belül érhetők el, azonban ezek konstansok, azaz értékük nem változik.
Forrás: http://es6-features.org/#Constants, http://es6-features.org/#BlockScopedVariables, https://www.w3schools.com/js/js\_es6.asp, https://www.sitepoint.com/how-to-declare-variables-javascript/

A PHP nyelv ebből a szempontban nagyon egyszerű, itt sem kell típust kiírni, és a változó deklarálásakor a név előtt egy \textdollar jelet kell megadni.

\begin{cpp}
	$valtozo = 8;	
\end{cpp}

\section{Tömbök definiálása}

A tömböket általánosságban hasonlóan kell definiálni az egyes célnyelveken, de itt is okozhatnak nehézséget a fordítóprogram megvalósítása szempontjából a kisebb különbségek is.

A C nyelvben a tömbök deklarálásához meg kell adni először a tömb típusát, majd a nevét, végül a tömb méretét [ és ] között. A tömböt azonnal fel is tölthetjük elemekkel, ekkor nem kell a tömb méretét külön megadni, csak az egyenlőségjel után { és } jel között kell felsorolni a tömb elemeit.
Ha csak az egyik elemet akarjuk módosítani akkor a név után [ és ] jel között meg kell adni hanyadik elemet akarjuk módosítani majd az elem értékét. A tömb mindig a 0-ás indexelésű lesz, azaz az első elem a 0. indexű.

\begin{cpp}
	int tomb[10];
	int tomb2[] = {1, 5, 10, 25};
	int tomb[2] = 4;
\end{cpp}

A Java nyelv hasonlóan működik, azzal a különbséggel, hogy a tömbök típusa után kell megadni a szögletes zárójelpárt, és a méretét csak az inicializálás során kell megadni.

\begin{cpp}
	int[] tomb;
	tomb = new int[5];
	
	int[] tomb2 = new int[]{3, 5, 2};
\end{cpp}

A tombök tekintetében a JavaScript, PHP és Python elég hasonlóan működik. Mindhárom nyelv esetében meg kell adni a tömb nevét, ami egy váltzó lesz, majd felsorolni a tömb elemeit, melyek többféle típusúak is lehetnek. Az adott tömbök futás alatt bővíthetők, tehát új elemet hozzá lehet adni a tömbökhöz. Ez utóbbival vigyázni kell, mivel egy adott változó direkt módon egy adott helyre történő beillesztése a tömbbe akár lyukakat is hagyhat a tömbben.

JavaScript alatt az alábbi módon valósítható meg a tömb kezelése:

\begin{cpp}
	var tomb = ["egy", "ketto"];
	
	console.log(tomb[1]);
	
	tomb[2] = "harom"; //Nem ajánlott használat
	tomb.push("harom"); //A tömb végére illeszti az elemet
	
	consloe.log(tomb.length); //Tömb méretének lekérdezése
\end{cpp}

Ugyanez a tömbkezelés Python alatt:

\begin{cpp}
	tomb = ["egy", "ketto"];
	
	print(tomb[1]);
	
	tomb.append("harom"); //A tömb végére illeszti az elemet
	
	print(len(tomb)); //Tömb méretének lekérdezése
\end{cpp}

És végül a kezelés PHP alatt az alábbi lesz:

\begin{cpp}
	$tomb = array("egy", "ketto");
	
	echo $tomb[1];
	
	$tomb[2] = "harom"; //Nem ajánlott
	array_push($tomb, "harom"); //A tömb végére illeszti az elemet
	
	echo count($tomb); //Tömb méretének lekérdezése
\end{cpp}


\section{Ciklusok}

A célnyelvként tekintett programozás nyelvekben a ciklusok megvalósítása nagyon hasonlóan működik, minden tekintett célnyelvben van elöltesztelő és hátultesztelő ciklus is. A ciklusokban minden esetben van egy feltétel, egy ciklusváltozó, melynek változása lesz a feltétellel összehasonlítva és egy ciklusmag, mely minden iterációban lefut.

A fontos különbség a tekintett célnyelvek között, hogy maga a nyelv sajátosságai megtalálhatók itt is, tehát például a Python nyelvnél nincs a ciklusmag { és } közé téve, de természetesen függetlenül ettől ez is blokkot képez. A többi nyelvnél általában a kapcsos zárójel kiírásával megjelenítik a blokkot.

A ciklusoknak a két fajtája, a while és a for minden nyelvben megtalálható.

\begin{cpp}
	for (int i = 1; i < 10; i++) {
		System.out.println(i + "\n");
	}

	int j = 1;
	while (j < 10) {
		System.out.println(j + "\n");
		j++;
	}
\end{cpp}

A fenti példa egy Java kód a ciklusokra. A C nyelvben ez a ciklusszervezés majdnem teljesen megegyezik, a fő különbség az, hogy a C nyelvben a változókat mindig előre, a program elején kell deklarálni, tehát az nem tehető meg a ciklus fejlécében.

A Python while ciklusa azonos a fenti kódban írtakkal, természetesen a nyelvi sajátosságok miatt fennálló különbségek kivételével. A for ciklus ebben az esetben kicsit megváltozik, de így is hasonlít a Java nyelvben található foreach ciklusra, mivel ilyenkor egy listán fut végig a ciklus.

\begin{cpp}
	tomb = ["egy", "ketto", "harom"];
	for i in tomb:
		print(i)
\end{cpp}

JavaScript és PHP alatt a ciklusok majdnem teljesen megegyeznek a Java kódban látható ciklusokkal, természetesen itt is meg kell említeni a nyelvi sajátosságokat (pládul a PHP változók előtt itt is szerepelnie kell a \textdollar szimbólum), melyek eltéréseket okoznak és melyeket figyelembe kell venni a kimeneti kód megalkotásakor.

\section{Függvények}

A függvények kezelése a célnyelvekben szintén hasonlóan működik. A függvényeknek kell legyen egy fejlécük, melyben megadjuk a nevüket, visszatérési értékük típusát ahol kell, és a paraméter listát, illetve szükséges egy függvénytörzs is.

A fő különbség itt a C nyelvben van, ahol a függvényeket előre definiálni kell, egy prototípust kell a program elején írni belőlük, melyben fel kell tüntetni a függvény visszatérési értékének típusát, nevét és a paraméterek típusait. Ez a C nyelv esetében azért szükséges mivel a programnak tudnia kell a függvényről a meghívás helyén, és régebbi konvenció szerint a program belépési pontja azaz a main függvény után írjuk a többi függvényt. Azonban ha minden függvény teljesen megírásra kerül a main függvény előtt, függvényprototípusokat nem szükséges definiálni. Ezt kihasználva a C nyelvre fordítás is egyszerűsödhet a függvények kezelése szempontjából.

\begin{cpp}
	public static void main(String[] args) {
		int i = 1;
		int j = 2;
		System.out.println(addFunction(i,j));
	}
	
	public int addFunction(int a, int b) {
		return a+b;
	}
\end{cpp}

A fenti Java kódban egy függvényt és annak meghívását lehet látni. A függvények és meghívásaik a többi célnyelvként tekintett programozási nyelven is hasonlóan működnek.

A fő különbség a Python nyelven, hogy itt a nyelvi sajátosságok miatt általában nem kell láthatósági módosítót és visszatérési érték típust megadni, ellenben a def kulcsszóval kell a függvény leírását bevezetni. Meghívása a Java nyelvhez hasonlóan a függvény nevével történik. Ahogy a függvény neve elé nem kell, úgy a paraméterlistában a paraméterek nevei elé sem kell a típus megjelölés, azonban az újabb Python verziókban a fentebb említett "hint" itt is használható.

A PHP esetében a különbség majdnem ugyanaz, mint a Python esetében, tehát nem kell láthatósági módosító és típusmegjelölés sem, viszont a függvényt itt is kulcsszóval kell bevezetni, ez pedig a function lesz a PHP esetében. A paraméterek elő itt is kell a változóknál említett \textdollar szimbólum.

A JavaScript esetében szintén ez a helyzet mint az előző két esetben, és itt is a function kulcsszóval kell bevezetni a függvényt.

A függvények esetében visszatérési érték is lehetséges, hiszen a függvénytörzsben elvégzett adatokkal akár vissza is térhet a függvény a meghívó függvénybe. Ezt a return utasítással kell megadni minden nyelvben.

Szintén érdekesség, hogy a függvények paraméterének a legtöbb nyelvben lehet egy alapértelmezett értéket adni, és amennyiben nem kap értéket a meghíváskor, akkor ezt a kezdeti értéket fogja használni.
A C nyelv ebből a szempontból sajnos kivétel, nem támogatott alapértelmezetten ez a megoldás, természetesen különböző módokon lehet olyan programot írni melyben akár struktúrákkal, akár több függvénnyel a fent leírt hatás elérhető, de ez nehézkes. A legközelebbi beépített megoldás ezzel kapcsolatban a változó paraméterekkel (varargs) megoldott függvény lenne, de ez nem a legegyszerűbb megoldás és itt az ellenőrzések sem egyszerűek.
Ugyanígy a Java nyelv sem támogatja ezt a funkciót. Természetesen itt is megoldhatók ezek, itt a függvénytúlterhelés (function overloading) lenne a megoldás, amely esetben több függvényt írunk ugyanazon néven különböző paraméterlistával (ezt a Java támogatja), és az egyes függvények csak meghívják a további függvényeket melyek mind több és több paramétert tartalmaznak, míg végül az eredetileg megírni kívánt függvényt is. Az egyes függvények pedig a több paraméterrel rendelkező függvényeket egy alapértelmezett paraméterrel hívják meg, így a felhasználó mindig azt a függvényt tudja meghívni amennyi paraméter éppen a rendelkezésére áll a többi pedig alapértelmezett értékekkel kerül kitöltésre. Sajnos a nagyobb függvények esetében ez is eléggé bonyolulttá teszi nem csak a kódot de az ellenőrzést és javítást is.

A JavaScript a ECMAScript 2015-től kezdődően támogatja az alapértelmezett paramétert, csakúgy mint a PHP és a Python is támogatja ezt, így ez a három célnyelv az ami a kód bonyolítása nélkül képes ezeket kezelni.

Minthogy két nyelv is van a célnyelvként választott nyelvek között mely ezt nem támogatja, ezért a rugalmasságot és egyszerűséget alapul véve a definiált nyelvben sem lesz egyenlőre ez a funkció benne, így alapértelmezett paramétereket nem tudnak a felhasználók megadni. A fordítóprogram további fejlesztésekor, a felhasználói visszajelzéseket figyelembe véve lehet kibővíteni ezzel a rendszert.

\section{Struktúra és osztály}

Általánosságban a kódot a célnyelvekben valamilyen struktúrába szervezik. A magas szintű, modern programozási nyelvek az osztályokba szervezést követik, azaz a kódot valamilyen szempont alapján különböző osztályokba szervezik és ezek együttműködnek a program futása során.

A dolgozat szempontjából célnyelvként vizsgált nyelvek szinte mindegyike támogatja az osztályokba szervezést, kivéve a C nyelvet, melyben máshogy lehet ehhez hasonló szerkezetet megoldani.

\begin{cpp}
	public class Osztaly {
		int a;
		
		public Osztaly(int a) {
			this.a = a;
		}
	
		public int getA() {
			return this.a;
		}
	}
\end{cpp}

A fenti rövid Java nyelven írt példa mutatja be az osztályokat. A vizsgált célnyelvek közül a C nyelvet kivéve az osztályok megalkotása ehhez hasonlóan működik, minden osztálynak kell egy neve legyen, adattagjai és metódusai. Java nyelven az osztálynak egy láthatósági módosítója is van. Az adott nyelveken az osztályoknak van egy kiemelt metódusuk, a konstruktor. A Java nyelven ez az osztály nevével ellátott függvény lesz, melynek nincs visszatérési értéke, ez inicializálja a változókat, melyeket osztályon belül adattagnak nevezünk. Java nyelven lehetőség van több konstruktort is írni a fentebb említett method overloading segítségével, így egy osztály többféle módon is példányosítható lesz.
A példányosítás után az egyes metódusokra (amennyiben elérhetőek) a . operátorral hivatkozhatunk.

JavaScript nyelven az osztály tulajdonképpen egy egyedi függvényként is tekinthető, azaz a megírt tartalom függvényként is definiálható lenne. Azonban az osztályban történő definiálás az áttekinthetőség és az egyszerűbb leírás miatt történt. JavaScriptben is a class kulcsszóval kell bevezetni az osztálydefiníciót, azonban láthatósági módosítót nem kell megadni hozzá. Itt is létezik konstruktor függvény, de itt a constructor néven kell megírni, és csak egy darab lehet belőle. A példányosítás után itt is a . operátorral hivatkozhatunk az osztály metódusaira, adattagjaira.

PHP nyelven szintén a class kulcsszóval kell bevezetni az osztály deklarálását, viszont itt különbség, hogy a konstruktort a \_\_constuct függvény néven kell megírni. Az osztály metódusaira és adattagjaira viszont itt a -> operátorral lehet hivatkozni.

A Python nyelven az előzőekhez hasonlóan szintén class kulcsszóval kell az osztályt létrehozni, viszont itt is másik néven szerepel a konstruktor, itt az \_\_init\_\_ függvényt kell megírni, melyet a nyelvi sajátosságok alapján a def kulcsszóval kell bevezetni. A metódusokra és adattagokra itt is a . operátorral lehet hivatkozni.

Ahogy fentebb említésre került, a C nyelv nem obejtum orientált nyelv, azaz osztályokat nem lehet definiálni, ezért ilyen esetben kerülő megoldás kell. A C nyelvben definiálhatunk struktúrákat, azonban itt problémát jelenthet, hogy a metódusokat nem tudjuk magában a struktúrában definiálni, azaz külön kell azokat definiálni és explicit átadni neki magát a struktúrát, hogy az adattagjait kezelni lehessen. Emiatt a program eléggé bonyolulttá válhat, könnyen összekeverhető, hogy melyik struktúrához mely függvények tartoznak. Ennek kivédésére különböző névkonvenciókat alkalmazhatunk. Viszont jelen dolgozat esetében nem kell a felhasználónak ilyennel foglalkoznia, hiszen a definiált nyelven megírt kódot a program fordítja le, így az állítja össze a célnyelvi megfelelőjét. Viszont sajnos ilyenkor ha a kimeneti programot tovább szeretné a felhasználó szerkeszteni akkor az nehézségeket okozhat, de mivel a bemeneti programot lehet a továbbiakban is szerkeszteni ezért a kimeneti fájlt nem szükséges szerkeszteni.
Az alábbiakban látható egy példa a C nyelven megírt osztályhoz hasonló program megvalósításra.

\begin{cpp}
	typedef struct osztalyDef {
		int a;
		int b;
	} osztaly;
	
	int osztaly_getA(osztaly* osztPeldany) {
		return osztPeldany->a;
	}
	
	int osztaly_getB(osztaly* osztPeldany) {
		return osztPeldany->b;
	}
	
	void osztaly_setA(osztaly* osztPeldany, int x) {
		osztPeldany->a = x;
	}
	
	void osztaly_setB(osztaly* osztPeldany, int x) {
		osztPeldany->b = x;
	}
	
	int osztaly_addNumber(osztaly* osztPeldany) {
		return osztPeldany->a + osztPeldany->b;
	}
	
	osztaly osztDef;
	
	int main()
	{
		osztaly_setA(&osztDef, 10);
		osztaly_setB(&osztDef, 5);
		
		printf("%d", osztaly_addNumber(&osztDef));
		
		return 0;
	}
\end{cpp}